<title>Groupement de serveurs</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="balancing.html">

<link rel="next" href="notifications.html">

<script src="../../../script.js"></script>

<h2 id="clustering">Groupement de serveurs</h2>

<p>Bon ! vous êtes arrivé jusque là. J’estime donc que vous comprenez, dans les grandes lignes, ce qu’est CouchDB et comment l’API fonctionne. Peut-être avez-vous même déployé une ou deux applications et que vous rencontrez un certain succès, ce qui vous amène à envisager le passage à l’échelle. Dans ce chapitre, nous allons mettre en place une grappe de serveurs (<em>cluster</em> en anglais) partitionnée ou fragmentée (<em>sharded</em> en anglais), laquelle va croître à un taux croissant à compter de sa mise en service.

<p>Dans un premier temps, nous nous intéresserons à la distribution des requêtes et des réponses dans une grappe CouchDB stable. Ensuite, nous verrons comment y inclure de la rendondance pour rendre un nœud hautement disponible. Ainsi, vous n’aurez plus à vous soucier de la perte d’une machine. En effet, dans une large grappe, vous devriez prévoir que 5 à 10% de vos machines connaîtront des problèmes (défaillance, performances dégradées) ; cela doit être pris en compte lors de la conception de la grappe pour qu’une défaillance ne nuise pas à la stabilité de l’ensemble. Enfin, nous nous pencherons sur la modification dynamique de la répartition des données en subdivisant ou en fusionnant des nœuds à l’aide du mécanisme de réplication.

<h3 id="lounge">Présentation du <em>CouchDB Lounge</em></h3>

<p><a href="http://tilgovi.github.com/couchdb-lounge/">CouchDB Lounge</a>
est une application mandataire (<em>proxy</em>) — originellement développée pour <a href="http://www.meebo.com">Meebo</a>, service de messagerie instantannée par navigateur — qui permet de partitionner et de <a href="http://www.cnrtl.fr/lexicographie/Grappeler">grappeler</a> des instances CouchDB. Lounge se compose de deux modules : le premier, <em>dumbproxy</em> s’occupe des « simples » requêtes GET et PUT visant à obtenir un document ; le second, <em>smartproxy</em> répartit les requêtes nécessitant de recourir à des vues.

<p><em>dumbproxy</em> traite toutes les requêtes qui n’utilisent pas le mécanisme de vues de CouchDB. C’est un module de <a href="http://nginx.net/">nginx</a>, serveur mandataire frontal (en anglais, <em>reverse proxy</em>) HTTP très performant. Puisque ce serveur est le point d’entrée de votre infrastructure, et parce qu’il intègre les mécanismes de mandataire, vous pouvez le configurer pour apporter la sécurité que vous désirez, le chiffrement, la répartition de charge, la compression des flux et, bien sûr, l’antémémoire (en anglais, <em>cache</em>) pour soulager vos bases de données.

<p>Quant à <em>smartproxy</em>, il traite uniquement les requêtes sur les vues CouchDB qu’il distribue entre les nœud de la grappe afin que les performances soient fonction de la puissance de celle-ci. Cela prend la forme d’un démon qui hante Twisted, <em>framework</em> Python de développement réseau orienté évènements et à hautes performances en plus d’être populaire.

<h3 id="hashing">Empreintes stabilisées</h3>

<p><em>NdT : le terme anglais <a href="http://en.wikipedia.org/wiki/Consistent_hashing"><em>consistent hashing</em></a> (empreintes stabilisées) ne semble pas avoir de traduction française courante. Il s’agit d’une technique de génération d’empreintes qui évite d’avoir à recalculer toutes les empreintes en cas d’ajout ou de suppression d’un espace (voir ci-après). Vous pourriez trouver l’explication anglaise de Wikipédia plus compréhensible que celle donnée ci-dessous.

<p>Le modèle de persistence CouchDB recourre à des identifiants uniques (ID) pour sauvegarder et ouvrir des documents. Aussi, c’est avec logique qu’au cœur de Lounge se trouve un système d’empreinte (<em>hash</em> en anglais) qui transforme ces identifiants de manière cohérente. À l’aide des premières lettres de cette empreinte, il sait vers quel nœud envoyer la requête. Vous pouvez paramétrer ce comportement en écrivant une <em>shard map</em>, laquelle se trouve d’un fichier texte de configuration.

<p>La clé d’espace (<em>keyspace</em> en anglais) compose la première partie de l’empreinte et identifie chaque nœud, ce qui vous permet de définir autant de nœuds que vous le désirez. La fonction d’empreinte produit une chaîne hexadécimale qui ne semble avoir aucune relation avec les identifiants de vos documents et, cela couplé à la clé d’espace, assure une répartition globalement équitable entre les nœuds. De plus, puisque la fonction d’empreinte est cohérente, plusieurs requêtes d’accès à un même document seront toujours dirigées vers le même nœud.

<p>L’idée qui consiste à diviser un ensemble de fragments à l’aide d’une clé d’espace peut être illustrée par un anneau certi d’empreintes. Chaque dégré (NdT : imaginez les marques d’une horloge) délimite la frontière entre deux partitions. La fonction d’empreinte assure la correspondance entre un identifiant de document à l’intérieur de l’anneau et sa position à l’extérieur de celui-ci. En outre, l’anneau est continu, ce qui vous permet toujours d’y ajouter de nouveaux nœuds ; pour cela, vous subdivisez un espace en plusieurs espaces. Ainsi, avec quatre serveurs physiques, vous pouvez partager l’espace en seize partitions indépendantes que vous répartissez de la manière suivante :

<div>

<table>

<tbody>

<tr><td>A</td><td>0,1,2,3</td></tr>

<tr><td>B</td><td>4,5,6,7</td></tr>

<tr><td>C</td><td>8,9,a,b</td></tr>

<tr><td>D</td><td>c,d,e,f</td></tr>

</tbody>

</table>

</div>

<p>Si l’empreinte de votre document commence par <code>0</code>, la requête sera envoyée au fragment <code>A</code>. Il en va de même pour <code>1</code>, <code>2</code> et <code>3</code>. En revanche, si elle commence par <code>c</code>, <code>d</code>, <code>e</code> ou <code>f</code>, la requête est envoyée à <code>D</code>. Par exemple, l’empreinte <code>71db329b58378c8fa8876f0ec04c72e5</code> est dirigée vers le nœud <code>B</code>, dans la base de données <code>7</code>, ce qui pourrait correspondre à <code>http://B.couches.local/db-7/</code> dans votre environnement. De cette manière, la table de correspondance fait le lien entre une empreinte et une base de données. Ne vous inquiétez pas si cela vous semble très compliqué : vous n’avez qu’à fournir le lien entre les fragments et les bases, Lounge s’occupera de générer l’anneau sans que vous ayez à mettre les mains dans le cambouis si vous ne le désirez pas.

<p>Nous pouvons faire le parallèle avec le web : puisque CouchDB utilise HTTP, le serveur mandataire peut répartir les documents en fonction de l’URL sans avoir à connaître le contenu accesible par l’URL. C’est un principe de l’approche REST et c’est un des avantages que nous procure HTTP. En pratique, cette correspondance est assurée par une empreinte de l’URL demandée, laquelle est comparée à la table de correspondance pour trouver la clé d’espace appropriée. Lougne n’a plus qu’à trouver le fragment correspondant dans sa configuration pour faire suivre la requête vers le bon serveur CouchDB.

<p>Le mécanisme d’empreintes stabilisées vous garantit l’accès aux documents que vous sauvegardez ainsi que l’égale répartition du stockage sur vos nœuds. De plus, la simplicité de la fonction d’empreinte (basée sur CRC32) vous permet de concevoir vos propres mandataires HTTP ou vos propres clients capables de s’adresse au bon serveur. 

<h4 id="storage">Redondance du stockage</h4>

<p>Le recours aux empreintes stabilisées répond à la problématique de répartition d’une base de données en fragments égaux, lesquels peuvent être répartis à leur tour sur différents serveurs. En revanche, cela ne met en rien vos données à l’abri. En effet, les données demeurent stockées à un seul endroit, les mettant ainsi à la merci d’un incident matériel ou logiciel. Vous ne pouvez considérer vos données en sécurité qu’à la condition qu’elles soient présentent en deux lieux différents, si possible géographiquement éloignés l’un de l’autre.

<p>Le mécanisme de réplication de CouchDB permet d’obtenir sans trop d’efforts les fonctionnalités de basculement immédiat vers des bases esclaves redondantes ou de répartition de charge en bases de données multi-maîtresses (c’est-à-dire en réplication bidirectionnelle). Le paramétrage de la réplication est expliqué au <a href="replication.html">chapitre 16, <em>Réplication</em></a>. Ce qui importe ici, c’est de comprendre que maintenir des copies redondantes doit être dissocié de la tâche, plus complexe, consistant à toujours faire correspondre à un identifiant de document donné, un fragment donné.

<p>Considérons que vous avez deux ou trois copie de chaque donnée pour en assurer la sécurité. Vous avez alors deux ou trois copies d’un même fragment. Du point de vue de la grappe, il n’existe qu’un fragment ; la duplication des données, la bascule en cas de défaillance et la répartition de charge sont assurées par le fragment en question.

<h4 id="proxies">Redondance des serveurs mandataires</h4>

<p>De la même manière que nous ne pouvons laisser une éventuelle défaillance matérielle provoquer une perte de données, nous aurons recours à plusieurs serveurs mandataires afin que la perte de l’un d’eux ne rendent pas nos bases inacessibles. Leur redondance ainsi que la répartition de charge entre eux augmentera la disponibilité et la capacité totale à absorber les requêtes.

<h4 id="merging">Fusion des vues</h4>

<p>Le mécanisme d’empreintes stabilisées dépose les documents sur les bons nœuds. Toutefois, il peuvent toujours émettre (<code>emit()</code>) n’importe quelle clé. L’intérêt de MapReduce incrémental est de déporter le traitement aux nœuds de sorte que nous n’avons pas à redistribuer les clés émises. Il s’agit de faire suivre la requête du client, via le mandataire HTTP, à tous les nœuds et de fusionner les résultats à l’aide du Twisted Python Smartproxy.

<p>Smartproxy envoie chaque requête de vue à tous les nœuds. Il doit donc fusionner les réponses avant de les envoyer au client. Heureusement, cette opération n’est pas consommatrice de ressources, car la fusion peut s’opérer à pérmiètre mémoire constant quel que soit la volumétrie. Smartproxy reçoit le premier enregistrement de chaque nœud de la grappe et les compare. Nous trions les nœuds selon leur clé d’enregistrement en appliquant les règles d’inteclassement de CouchDB. Ensuite, Smartproxy récupère le premier enregistrement du nœud qu’il vient de classer premier et l’envoie au client.

<p>Ce processus peut se poursuivre tant que les clients envoient des enregistrements, mais si une limite est donnée par le client, Smartproxy doit achever le traitement aussitôt et dédaigner les autres enregistrement dont lui font part les nœuds.

<p>Cette approche est simple et faiblement couplée. Elle présente l’avantage d’être simple, ce qui permet de plus facilement appréhender la topologie et d’analyser les erreurs. Il y a du travail pour réussir à transplanter ce comportement en Erlang, mais cela nous permettrait de gérer des grappes dynamiques et d’intégrer le contrôle des ces derniers dans le cœur de CouchDB.

<h3 id="growing">Étendre la grappe</h3>

<p>L’utilisation de CouchDB à l’échelle du web nécessite vraisemblablement d’avoir des grappes qui peuvent s’étendre de manière dynamique. Les sites en forte croissance ajoutent sans cesse de nouveaux espaces de stockage ; nous avons par conséquent besoin de pouvoir augmenter la taille de notre grappe sans pour autant l’arrêter. En outre, certaines charges provoquent une augmentation épisodique de la taille de la base, ce qui induit la nécessité d’un processus de réduction de la grappe sans interrompre son fonctionnement.

<p>Dans cette section, nous verrons comment utiliser les filtres de réplication de CouchDB pour subdiviser une base de données en plusieurs fragments, et comment utiliser cette technique pour étendre notre grappe sans l’arrêter. Vous pouvez en quelques étapes éviter de partionner les bases de données en étendant la grappe.

<p>La technique de <em>fragmentation zélée</em> (<em>oversharding</em> en anglais) consiste à partitionner la grappe de manière à avoir plusieurs fragments sur un même hôte physique. En effet, déplacer un fragment d’une machine vers une autre est une tâche plus simple que de le subdiviser, car seule la configuration de la grappe telle que décrite dans le serveur mandataire doit être mise à jour pour pointer vers le nouveau serveur, plutôt que de devoir y inclure de nouveaux fragments. Cela nécessite moins de ressources de migrer un fragment que de le subdiviser.

<p>La question que nous devons alors nous poser est de savoir quel zèle est nécessaire. La réponse est fonction de votre application et de votre déploiement, mais il est des éléments qui nous poussent davantage d’un côté que de l’autre. Si nous taillons correctement nos fragments, nous obtiendrons un serveur qui pourra s’étendre de manière optimale.

<p>Dans <a href="#merging">la section <em>Fusion des vues</em></a>, nous avons vu que la fusion se fait à espace constant quel que soit le nombre d’enregistrements retournés. En revanche, l’espace mémoire et les ressources réseau nécessaires à la fusion des vues, tout comme la correspondance d’un identifiant de document à un fragment, croissent linéairement en fonction du nombre de fragments gérés par un mandataire. Cependant, nous ne pouvons souffrir une borne supérieure à la taille de notre grappe. En conséquence, la solution réside dans l’utilisation d’un arbe de serveurs mandataires dans lequel la racine fait suivre à des mandataires secondaires, lesquelles accèdent aux nœuds.

<p>Les facteurs à prendre en compte lors de la détermination du nombre de fragments que chaque mandataire doit pouvoir gérer sont : l’espace disque disponible pour chaque nœud, l’estimation de croissance des données, le réseau et les ressources mémoires mises à la disposition des serveurs mandataires et la latence acceptable pour traverser la grappe.

<p>Ainsi, avec un réglage conservateur de 64 fragments par mandataire et de 1 TB d’espace utile par nœud (avec la compression, ces nœuds auront besoin d’environ 2 TB d’espace disque), nous pouvons voir qu’avec un seul mandataire devant les bases CouchDB, nous pourrons stocker au maximum 64 TB de données (sur 128 ou peut-être 192 nœuds, selon le niveau de redondance nécessaire) avant d’avoir à augmenter le nombre de fragments.

<p>En substituant des nœuds par un nouveau mandataire, et en subdivisant chacun des 64 fragments en 64 nouveaux fragments, nous arrivons à 4 096 fragments et une profondeur d’arbre de 2. De la même manière que le système initial pouvait faire tenir 64 fragments sur seulement quelques nœuds, nous pouvons passer à un arbre à deux niveaux sans avoir besoin de milliers de machines. Si nous acceptons l’hypothèse que chaque mandataire doit avoir son propre serveur et qu’une base de donnée peut accueillir 16 fragments, nous arrivons à 65 serveurs mandataires et 256 serveurs de bases de données (sans prendre en compte ceux requis pour la redondance qui multiplient ce nombre par deux ou trois). Ainsi, pour commencer avec une grappe qui pourra croître tranquillement de 64 TB à 4 PB, nous pouvons commencer avec environ 600 à 1 000 nœuds, en ajoutant de nouveaux nœuds quand la taille des données augmente et en déplaçant les fragments vers de nouvelles machines.

<p>Nous savons donc qu’une grappe avec une profondeur d’arbre de deux peut accueillir une grande quantité de données. Des opérations mathématiques simples nous montrent qu’en appliquant le même raisonnement à une grappe d’une profondeur de trois, nous pouvons héberger 262 PB sur des milliers de machines. Des estimations conservatrices estiment la latence introduite par chaque niveau à 100 ms, donc même sans ajustements, le temps de réponse serait de 300 ms pour une profondeur d’arbre de 3, et nous serions capables d’exécuter des requêtes sur plus d’un exaoctet de données en moins d’une seconde.

<p>En recourrant à la technique de fragmentation zélée et en replaçant les fragments pleins (<em>full shard</em> en anglais ; nœuds qui hébergent un unique fragment) par des serveurs mandataires, nous pouvons étendre la grappe jusqu’à une taille collossale tout en subissant une latence minimale.

<p>Maintenant, nous allons nous pencher sur les mécanismes de deux processus qui permettent à la grappe de croître : déplacer un fragment d’un serveur surchargé à un nœud vide et subdiviser un fragment. Déplacer des fragments est une opération simple, ce qui invite à l’utiliser tant que c’est possible. Ainsi, nous gardons l’opération plus gourmande de subdivision pour les cas où un fragment devient si gros qu’un seul, ou que deux fragments occuppent à eux seuls tout un serveur.

<h4 id="moving">Moving Partitions</h4>

<p>As we mentioned earlier, each partition is made up of <em>N</em> redundant CouchDB databases, each stored on different physical servers. To keep things easy to conceptualize, any operations should be applied to all redundant copies automatically. For the sake of discussion, we’ll just talk about the abstract partition, but be aware that the redundant nodes will all be the same size and so should require the same operations during cluster growth.

<p>The simplest way to move a partition from one node to another is to create an empty database on the target node and use CouchDB replication to fill the new node with data from the old node. When the new copy of the partition is up-to-date with the original, the proxy node can be reconfigured to point to the new machine. Once the proxy points to the new partition location, one final round of replication will bring it up-to-date, and the old partition can be retired, freeing space on the original machine.

<p>Another method for moving partition databases is to rsync the files on disk from the old node to the new one. Depending on how recently the partition was compacted, this should result in efficient, low-CPU initialization of a new node. Replication can then be used to bring the rsynced file up-to-date. See more about rsync and replication in <a href="replication.html">Chapter 16, Replication</a>.

<h4 id="splitting">Splitting Partitions</h4>

<p>The last major thing we need to run a CouchDB cluster is the capability to split an oversized partition into smaller pieces. In <a href="replication.html">Chapter 16, Replication</a>, we discussed how to do continuous replication using the <code>_changes API</code>. The <code>_changes API</code> can use filters (see <a href="notifications.html">Chapter 20, Change Notifications</a>), and replication can be configured to use a filter function to replicate only a subset of a total database. Splitting partitions is accomplished by creating the target partitions and configuring them with the range of hash keys they are interested in. They then apply filtered replication to the source partition database, requesting only documents that meet their hash criteria. The result is multiple partial copies of the source database, so that each new partition has an equal share of the data. In total, they have a complete copy of the original data. Once the replication is complete and the new partitions have also brought their redundant backups up-to-date, a proxy for the new set of partitions is brought online and the top-level proxy is pointed at it instead of the old partition. Just like with moving a partition, we should do one final round of replication after the old partition is no longer reachable by the cluster, so that any last second updates are not lost. Once that is done, we can retire the old partition so that its hardware can be reused elsewhere in the cluster.
