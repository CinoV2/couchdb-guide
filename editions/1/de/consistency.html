<title>Letzendliche Konsistenz</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="why.html">

<link rel="next" href="tour.html">

<script src="../../../script.js"></script>

<h2 id="consistency">Letzendliche Konsistenz</h2>

<p>Im letzten Kapitel haben wurde gezeigt, dass die Flexibilität von CouchDB es  erlaubt, die Daten weiter zu entwickeln, während die Anwendungen wachsen und sich ändern. In diesem Kapitel wird untersucht, wie das Arbeiten mit CouchDB (anstatt gegen CouchDB) Einfachheit in den Anwendungen fördert und natürlich zu skalierbaren, verteilten Systemen führt.

<h3 id="grain">Arbeiten mit CouchDB</h3>

<p>Ein <em>verteiltes System</em> ist ein System, welches zuverlässig über ein großes Netzwerk funktioniert. Eine spezielle Eigenschaft von Netzwerken ist, das Verbindungen jederzeit abbrechen können und es gibt viele Strategien, wie man mit dieser Situation umgehen kann. CouchDB unterscheidet sich von anderen Systemen dadurch, dass es Letzendliche Konsistenz akzeptiert - im Gegensatz zu RDBMS und Paxos, die Absoluter Konsistenz über schlichte Verfügbarkeit stellen. All diese Systeme haben gemein, dass sich Daten anders verhalten, wenn viele Leute versuchen gleichzeitig auf sie zuzugreifen. Ihre Ansätze unterscheiden sich, wenn es um die Gewichtung von <em>Konsistenz</em>, <em>Verfügbarkeit</em> oder <em>Partitionstoleranz</em> geht.

<p>Verteilte Systeme zu entwerfen ist nicht einfach. Viele der Stolperfallen, die über die Zeit auftauchen, sind nicht sofort klar. CouchDB hat nicht alle Antworten und es ist auch keine Allheilmittel. Wenn man jedoch mit anstatt gegen CouchDB arbeitet, führen die so entwickelten Anwendungen automatisch zu skalierbaren Systemen. 

<p>Sicher ist die Entwicklung eines verteilten Systems nur der Anfang. Eine Webseite mit einer Datenbank ist nahezu nutzlos, wenn sie nur die Hälfte der Zeit erreichbar ist. Leider macht es der traditionelle Ansatz, die Konsistenz mit Hilfe eines RDBMS sicherzustellen, den Entwicklern sehr leicht, sich auf einen globalen Zustand, synchronisierte Uhren und andere Dinge zu verlassen, die in hochverfügbaren Systemen nicht sichergestellt werden können. Meist tun sie das ohne sich dessen bewusst zu sein. Bevor wir untersuchen, wie CouchDB Skalierbarkeit fördert, schauen wir auf die Randbedingungen von verteilten Systemen. Nachdem wir die Probleme gesehen haben, die entstehen, wenn Teile einer Anwendung sich nicht mehr darauf verlassen kann, auf andere Teile ständig zugreifen zu können, sehen wir, wie CouchDB einen intuitiven und sinnvollen Weg weist, um hochverfügbare Anwendungen zu entwickeln. 

<h3 id="cap">Das CAP-Theorem</h3>

<p>Das CAP-Theorem (CAP = Consistency, Avalability, Partition Tolerance) beschreibt einige Strategien um Anwendungslogik über ein Netzwerk zu verteilen. CouchDB verwendet Replikation um Änderungen zwischen den einzelnen Knoten zu synchronisieren. Das ist ein fundamental anderer Ansatz als der von Konsens-Algorithmen und relationalen Datenbanken, die an anderen Schnittpunkten von Konsistenz, Verfügbarkeit und Partitionstoleranz liegen.

<p>Das CAP-Theorem in <a href="#figure/1">Abbildung 1: “Das CAP-Theorem”</a> identifiziert drei separate Bereiche:

<dl>

<dt>Konsistenz</dt>

<dd>Alle Datenbank Nutzer sehen die gleichen Daten - selbst bei konkurrierenden Updates.</dd>

<dt>Verfügbarkeit</dt>

<dd>Alle Datenbank Nutzer können auf irgendeine Version der Daten zugreifen.</dd>

<dt>Partitionstoleranz</dt>

<dd>Die Datenbank kann über mehrere Server verteilt sein.</dd>

</dl>

<p>Wähle zwei aus.

<div class="figure" id="figure/1">

<img src="consistency/01.png">

<p class="caption">Abbildung 1: Das CAP-Theorem

</div>

<p>Wenn ein System so groß wird, sodass ein einzelner Datenkbank Server nicht mehr in der Lage ist, die Last zu bewältigen, ist eine sinnvolle Lösung mehr Server hinzuzufügen. Mehrere Server bedeutet jedoch, dass die Daten zwischen den Server partitioniert werden müssen. Haben einige wenige Datenbank Server immer exakt die gleichen Daten? Haben verschiedene Datenkbank Server verschiedene Teile der Daten? Sind Schreibzugriffe nur auf bestimmten Servern erlaubt und die anderen verarbeiten die Lesezugriffe?

<p>Egal welchen Ansatz man wählt, das eigentliche Problem, wie all diese Server synchronisiert werden, bleibt bestehen. Wenn man eine Information in einen Knoten schreibt, wie stellt man sicher, dass der nächste Lesezugriff auf einem anderen Server die neusten Daten liefert. Die Zugriffe können nur Millisekunden auseinander liegen. Selbst mit einer kleinen Anzahl von Datenkbank Servern kann dieses Problem sehr komplex werden.

<p>Wenn es absolut erforderlich ist, dass alle Nutzer eine konsistente Sicht auf die Datenbank haben, dann müssen die Nutzer des einen Knotens darauf warten, bis alle anderen Knoten sich synchronisiert haben, bevor sie wieder lesen oder schreiben können. In diesem Fall muss die <em>Verfügbarkeit</em> hinter die <em>Konsistenz</em> zurücktreten. Es gibt aber auch Fälle, in denen Verfügbarkeit wichtiger ist als Konsistenz:

<blockquote>

<p>Jeder Knoten in einem System sollte in der Lage sein, Entscheidungen zu treffen, die ausschließlich auf dem lokalen Zustand basieren. Wenn man etwas unter großer Last machen muss während gleichzeitig Fehler auftreten und man muss auf die Synchronisation warten, hat man verloren. Wenn Skalierbarkeit wichtig ist, wird jeder Algorithmus, der eine Synchronisierung erzwingt, irgendwann zum Flaschenhals werden. Nimm das als gegeben an.

<p class="attribution">&mdash;Werner Vogels, Amazon CTO und Vice President

</blockquote>

<p>If availability is a priority, we can let clients write data to one node of the database without waiting for other nodes to come into agreement. If the database knows how to take care of reconciling these operations between nodes, we achieve a sort of “eventual consistency” in exchange for high availability. This is a surprisingly applicable trade-off for many applications.

<p>Unlike traditional relational databases, where each action performed is necessarily subject to database-wide consistency checks, CouchDB makes it really simple to build applications that sacrifice immediate consistency for the huge performance improvements that come with simple distribution.

<h3 id="local">Local Consistency</h3>

<p>Before we attempt to understand how CouchDB operates in a cluster, it’s important that we understand the inner workings of a single CouchDB node. The CouchDB API is designed to provide a convenient but thin wrapper around the database core. By taking a closer look at the structure of the database core, we’ll have a better understanding of the API that surrounds it.

<h4 id="key">The Key to Your Data</h4>

<p>At the heart of CouchDB is a powerful <em>B-tree</em> storage engine. A B-tree is a sorted data structure that allows for searches, insertions, and deletions in logarithmic time. As <a href="#figure/2">Figure 2, “Anatomy of a view request”</a> illustrates, CouchDB uses this B-tree storage engine for all internal data, documents, and views. If we understand one, we will understand them all.

<div class="figure" id="figure/2">

<img src="consistency/02.png">

<p class="caption">Figure 2. Anatomy of a view request

</div>

<p>CouchDB uses MapReduce to compute the results of a view. MapReduce makes use of two functions, “map” and “reduce,” which are applied to each document in isolation. Being able to isolate these operations means that view computation lends itself to parallel and incremental computation. More important, because these functions produce key/value pairs, CouchDB is able to insert them into the B-tree storage engine, sorted by key. Lookups by key, or key range, are extremely efficient operations with a B-tree, described in <em>big O notation</em> as <em>O(log N)</em> and <em>O(log N + K)</em>, respectively.

<p>In CouchDB, we access documents and view results by key or key range. This is a direct mapping to the underlying operations performed on CouchDB’s B-tree storage engine. Along with document inserts and updates, this direct mapping is the reason we describe CouchDB’s API as being a thin wrapper around the database core.

<p>Being able to access results by key alone is a very important restriction because it allows us to make huge performance gains. As well as the massive speed improvements, we can partition our data over multiple nodes, without affecting our ability to query each node in isolation. <em>BigTable</em>, <em>Hadoop</em>, <em>SimpleDB</em>, and <em>memcached</em> restrict object lookups by key for exactly these reasons.

<h4 id="locking">No Locking</h4>

<p>A table in a relational database is a single data structure. If you want to modify a table—say, update a row—the database system must ensure that nobody else is trying to update that row and that nobody can read from that row while it is being updated. The common way to handle this uses what’s known as a <em>lock</em>. If multiple clients want to access a table, the first client gets the lock, making everybody else wait. When the first client’s request is processed, the next client is given access while everybody else waits, and so on. This serial execution of requests, even when they arrived in parallel, wastes a significant amount of your server’s processing power. Under high load, a relational database can spend more time figuring out who is allowed to do what, and in which order, than it does doing any actual work.

<p>Instead of locks, CouchDB uses <em>Multi-Version Concurrency Control (MVCC)</em> to manage concurrent access to the database. <a href="#figure/3">Figure 3, “MVCC means no locking”</a> illustrates the differences between MVCC and traditional locking mechanisms. MVCC means that CouchDB can run at full speed, all the time, even under high load. Requests are run in parallel, making excellent use of every last drop of processing power your server has to offer.

<div class="figure" id="figure/3">

<img src="consistency/03.png">

<p class="caption">Figure 3. MVCC means no locking

</div>

<p>Documents in CouchDB are versioned, much like they would be in a regular version control system such as Subversion. If you want to change a value in a document, you create an entire new version of that document and save it over the old one. After doing this, you end up with two versions of the same document, one old and one new.

<p>How does this offer an improvement over locks? Consider a set of requests wanting to access a document. The first request reads the document. While this is being processed, a second request changes the document. Since the second request includes a completely new version of the document, CouchDB can simply append it to the database without having to wait for the read request to finish.

<p>When a third request wants to read the same document, CouchDB will point it to the new version that has just been written. During this whole process, the first request could still be reading the original version.

<p>A read request will always see the most recent snapshot of your database.

<h4 id="validation">Validation</h4>

<p>As application developers, we have to think about what sort of input we should accept and what we should reject. The expressive power to do this type of validation over complex data <em>within</em> a traditional relational database leaves a lot to be desired. Fortunately, CouchDB provides a powerful way to perform per-document validation from within the database.

<p>CouchDB can validate documents using JavaScript functions similar to those used for MapReduce. Each time you try to modify a document, CouchDB will pass the validation function a copy of the existing document, a copy of the new document, and a collection of additional information, such as user authentication details. The validation function now has the opportunity to approve or deny the update.

<p>By working with the grain and letting CouchDB do this for us, we save ourselves a tremendous amount of CPU cycles that would otherwise have been spent serializing object graphs from SQL, converting them into domain objects, and using those objects to do application-level validation.

<h3 id="distributed">Distributed Consistency</h3>

<p>Maintaining consistency within a single database node is relatively easy for most databases. The real problems start to surface when you try to maintain consistency between multiple database servers. If a client makes a write operation on server <em>A</em>, how do we make sure that this is consistent with server <em>B</em>, or <em>C</em>, or <em>D</em>? For relational databases, this is a very complex problem with entire books devoted to its solution. You could use multi-master, master/slave, partitioning, sharding, write-through caches, and all sorts of other complex techniques.

<h4 id="incremental">Incremental Replication</h4>

<p>Because CouchDB operations take place within the context of a single document, if you want to use two database nodes, you no longer have to worry about them staying in constant communication. CouchDB achieves <em>eventual consistency</em> between databases by using incremental replication, a process where document changes are periodically copied between servers. We are able to build what’s known as a <em>shared nothing</em> cluster of databases where each node is independent and self-sufficient, leaving no single point of contention across the system.

<p>Need to scale out your CouchDB database cluster? Just throw in another server.

<p>As illustrated in <a href="#figure/4">Figure 4, “Incremental replication between CouchDB nodes”</a>, with CouchDB’s incremental replication, you can synchronize your data between any two databases however you like and whenever you like. After replication, each database is able to work independently.

<p>You could use this feature to synchronize database servers within a cluster or between data centers using a job scheduler such as <em>cron</em>, or you could use it to synchronize data with your laptop for offline work as you travel. Each database can be used in the usual fashion, and changes between databases can be synchronized later in both directions.

<div class="figure" id="figure/4">

<img src="consistency/04.png">

<p class="caption">Figure 4. Incremental replication between CouchDB nodes

</div>

<p>What happens when you change the same document in two different databases and want to synchronize these with each other? CouchDB’s replication system comes with automatic conflict detection <em>and</em> resolution. When CouchDB detects that a document has been changed in both databases, it flags this document as being in conflict, much like they would be in a regular version control system.

<p>This isn’t as troublesome as it might first sound. When two versions of a document conflict during replication, the <em>winning</em> version is saved as the most recent version in the document’s history. Instead of throwing the <em>losing</em> version away, as you might expect, CouchDB saves this as a previous version in the document’s history, so that you can access it if you need to. This happens automatically and consistently, so both databases will make exactly the same choice.

<p>It is up to you to handle conflicts in a way that makes sense for your application. You can leave the chosen document versions in place, revert to the older version, or try to merge the two versions and save the result.

<h4 id="study">Case Study</h4>

<p>Greg Borenstein, a friend and coworker, built a small library for converting Songbird playlists to JSON objects and decided to store these in CouchDB as part of a backup application. The completed software uses CouchDB’s MVCC and document revisions to ensure that Songbird playlists are backed up robustly between nodes.

<div class="aside note">

<p>Songbird is a free software media player with an integrated web browser, based on the Mozilla XULRunner platform. Songbird is available for Microsoft Windows, Apple Mac OS X, Solaris, and Linux.

</div>

<p>Let’s examine the workflow of the Songbird backup application, first as a user backing up from a single computer, and then using Songbird to synchronize playlists between multiple computers. We’ll see how document revisions turn what could have been a hairy problem into something that <em>just works</em>.

<p>The first time we use this backup application, we feed our playlists to the application and initiate a backup. Each playlist is converted to a JSON object and handed to a CouchDB database. As illustrated in <a href="#figure/5">Figure 5, “Backing up to a single database”</a>, CouchDB hands back the document ID and revision of each playlist as it’s saved to the database.

<div class="figure" id="figure/5">

<img src="consistency/05.png">

<p class="caption">Figure 5. Backing up to a single database

</div>

<p>After a few days, we find that our playlists have been updated and we want to back up our changes. After we have fed our playlists to the backup application, it fetches the latest versions from CouchDB, along with the corresponding document revisions. When the application hands back the new playlist document, CouchDB requires that the document revision is included in the request.

<p>CouchDB then makes sure that the document revision handed to it in the request matches the current revision held in the database. Because CouchDB updates the revision with every modification, if these two are out of synchronization it suggests that someone else has made changes to the document between the time we requested it from the database and the time we sent our updates. Making changes to a document after someone else has modified it without first inspecting those changes is usually a bad idea.

<p>Forcing clients to hand back the correct document revision is the heart of CouchDB’s optimistic concurrency.

<p>We have a laptop we want to keep synchronized with our desktop computer. With all our playlists on our desktop, the first step is to “restore from backup” onto our laptop. This is the first time we’ve done this, so afterward our laptop should hold an exact replica of our desktop playlist collection.

<p>After editing our Argentine Tango playlist on our laptop to add a few new songs we’ve purchased, we want to save our changes. The backup application replaces the playlist document in our laptop CouchDB database and a new document revision is generated. A few days later, we remember our new songs and want to copy the playlist across to our desktop computer. As illustrated in <a href="#figure/6">Figure 6, “Synchronizing between two databases”</a>, the backup application copies the new document and the new revision to the desktop CouchDB database. Both CouchDB databases now have the same document revision.

<div class="figure" id="figure/6">

<img src="consistency/06.png">

<p class="caption">Figure 6. Synchronizing between two databases

</div>

<p>Because CouchDB tracks document revisions, it ensures that updates like these will work only if they are based on current information. If we had made modifications to the playlist backups between synchronization, things wouldn’t go as smoothly.

<p>We back up some changes on our laptop and forget to synchronize. A few days later, we’re editing playlists on our desktop computer, make a backup, and want to synchronize this to our laptop. As illustrated in <a href="#figure/7">Figure 7, “Synchronization conflicts between two databases”</a>, when our backup application tries to replicate between the two databases, CouchDB sees that the changes being sent from our desktop computer are modifications of out-of-date documents and helpfully informs us that there has been a conflict.

<p>Recovering from this error is easy to accomplish from an application perspective. Just download CouchDB’s version of the playlist and provide an opportunity to merge the changes or save local modifications into a new playlist.

<div class="figure" id="figure/7">

<img src="consistency/07.png">

<p class="caption">Figure 7. Synchronization conflicts between two databases

</div>

<h3 id="wrap">Wrapping Up</h3>

<p>CouchDB’s design borrows heavily from web architecture and the lessons learned deploying massively distributed systems on that architecture. By understanding why this architecture works the way it does, and by learning to spot which parts of your application can be easily distributed and which parts cannot, you’ll enhance your ability to design distributed and scalable applications, with CouchDB or without it.

<p>We’ve covered the main issues surrounding CouchDB’s consistency model and hinted at some of the benefits to be had when you work <em>with</em> CouchDB and not against it. But enough theory—let’s get up and running and see what all the fuss is about!
