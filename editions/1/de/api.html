<title>Das Core API</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="tour.html">

<link rel="next" href="design.html">

<script src="../../../script.js"></script>

<h2 id="api">Das Core API</h2>

<p>In diesem Kaptiel nehmen wir CouchDB genau unter die Lupe. Wir gehen richtig in die Details und zeigen knifflige Sachen. Wir erklären die Best Practices und helfen die üblichen Stolperfallen zu umgehen.

<p>Zu Beginn gehen wir noch einmal die Grundoperationen durch, die wir bereits im letzten Kapitel vorgestellt haben und schauen anschließend unter die Haube. Wir zeigen auch, was Futon hinter der Benutzerschnittstelle machen muss, um die vielen Funktionen zu haben, die wir zuvor gesehen haben.

<p>Dieses Kapitel ist zugleich eine Einführung in das Core API von CouchDB und eine Referenz. Wenn sie sich nicht mehr erinnern können, wie ein bestimmter Request funktioniert oder warum bestimmte Parameter benötigt werden, können sie jederzeit hierhin zurückkehren und nachschlagen. Von allen Kapiteln nutzen wir dieses wahrscheinlich am häufigsten.

<p>Während wir das API genauer erklären, müssen wir manchmal etwas weiter ausholen, um die Motivation hinter einem Request zu erklären. Dabei können wir gleich erklären, warum CouchDB so funktioniert wie es funktioniert.

<p>Das API kann man in folgende Bereiche aufteilen, die wir nacheinander besprechen werden:

<ul>

<li>Server</li>

<li>Databanken</li>

<li>Dokumente</li>

<li>Replikation</li>

</ul>

<h3 id="server">Server</h3>

<p>Der erste Request ist simpel. Man benutzt ihn um zu sehen ob CouchDB überhaupt läuft. Setzt eine externe Bibliothek eine bestimmte Version voraus, kann sie mit diesem Request prüfen, ob diese Bedingung erfüllt ist. Wir nutzen wieder <code>curl</code> um mit CouchDB zu sprechen:

<pre>
curl http://127.0.0.1:5984/
</pre>

<p>Voller Erwartung antwortet CouchDB mit:

<pre>
{"couchdb":"Welcome","version":"0.10.1"}
</pre>

<p>Zurück kommt ein JSON String, der einen Willkommensgruß und die Version von CouchDB enthält.

<p>Damit kann man zwar nicht viel anfangen, allerdings zeigt es, wie sich CouchDB verhält. Man schickt einen HTTP Request und bekommt einen JSON String als HTTP Response.

<h3 id="databases">Datenbanken</h3>

<p>Machen wir etwas Sinnvolleres: Legen wir eine Datenbank an. Wenn man es genau nimmt, ist CouchDB ein <em>Datenbank Management System (DBMS)</em>, weil es mehrere <em>Datenbanken</em> enthalten kann. Eine Datenbank ist ein Behälter, der „zusammenhängende Daten“ enthält. Wir werden später sehen was das genau bedeutet. Meist verschwimmen die Begriffe etwas und „die Datenbank“ sind dann zugleich das DBMS und die Datenbank darin. Wir nehmen es auch nicht so genau, denn aus dem Kontext geht meist hervor, ob CouchDB als Ganzes oder eine Datenbank darin gemeint ist.

<p>Legen wir die Datenbank nun an – zum Beispiel um unsere Lieblingsalben zu speichern. Sinnigerweise nennen wir die Datenbank <code>albums</code>. Datenbanken werden in CouchDB mit einem <code>PUT</code> Request angelegt. Deshalb nehmen wir bei <code>curl</code> die <code>-X</code> Option. Anderfalls würde <code>curl</code> einen <code>GET</code> Request schicken.

<pre>
curl -X PUT http://127.0.0.1:5984/albums
</pre>

<p>CouchDB antwortet mit:

<pre>
{"ok":true}
</pre>

<p>Das war's. Sie haben eine Datenbank angelegt und CouchDB sagt, das alles funktioniert hat. Was passiert, wenn man versucht eine Datenbank anzulegen, die bereits existiert sehen wir, wenn wir versuchen, die gleiche Datenbank nochmal anzulegen:

<pre>
curl -X PUT http://127.0.0.1:5984/albums
</pre>

<p>CouchDB antwortet mit:

<pre>
{"error":"file_exists","reason":"The database could not be created, the file already exists."}
</pre>

<p>CouchDB antwortet mit einem Fehler, was sehr praktisch ist. Zugleich lernen wir wieder ein wenig mehr darüber, wie CouchDB arbeitet. CouchDB speichert jede Datenbank in einer eigenen Datei. Ganz einfach. Daraus ergeben sich einige Konsequenzen, auf die wir jedoch erst später eingehen. Schauen wir zunächst auf das zugrundeliegende Speichersystem in <a href="btree.html">Anhang F - Die Macht der B-Trees</a>.

<p>Legen wir noch eine Datenbank an – diesmal mit der <code>-v</code> Option (für „verbose“) von <code>curl</code>. Mit dieser Option zeigt <code>curl</code> nicht nur die wesentlichen Teile – den HTTP Response Body – sondern alle Bestandteile des Requests an.

<pre>
curl -vX PUT http://127.0.0.1:5984/albums-backup
</pre>

<p><code>curl</code> zeigt:

<pre>
* About to connect() to 127.0.0.1 port 5984 (#0)
*   Trying 127.0.0.1... connected
* Connected to 127.0.0.1 (127.0.0.1) port 5984 (#0)
&gt; PUT /albums-backup HTTP/1.1
&gt; User-Agent: curl/7.16.3 (powerpc-apple-darwin9.0) libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
&gt; Host: 127.0.0.1:5984
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 201 Created
&lt; Server: CouchDB/0.9.0 (Erlang OTP/R12B)
&lt; Date: Sun, 05 Jul 2009 22:48:28 GMT
&lt; Content-Type: text/plain;charset=utf-8
&lt; Content-Length: 12
&lt; Cache-Control: must-revalidate
&lt;
{"ok":true}
* Connection #0 to host 127.0.0.1 left intact
* Closing connection #0
</pre>

<p>Wupps, das ist doch einiges mehr als ohne <code>-v</code>. Gehen wir der Reihe nach durch die einzelnen Zeilen, um zu verstehen, was genau passiert ist und was wichtig ist. Wenn man diese Ausgabe ein paarmal gesehen hat, weiß man worauf man achten muss und sieht die wichtigen Teile sofort.

<pre>
* About to connect() to 127.0.0.1 port 5984 (#0)
</pre>

<p>Damit sagt <code>curl</code> uns, dass es eine TCP Verbindung zu dem CouchDB Server aufbauen wird, den wir in dem Request URL angegeben haben. Das ist meist nicht besonders wichtig, ausser man sucht gerade einen Fehler im Netzwerk.

<pre>
*   Trying 127.0.0.1... connected
* Connected to 127.0.0.1 (127.0.0.1) port 5984 (#0)
</pre>

<p><code>curl</code> sagt uns mit diesen Zeilen, dass es sich erfolgreich mit CouchDB verbunden hat. Wieder nicht besonders wichtig, ausser man kämpft mit Netzwerkfehlern.

<p>Die folgenden Zeilen beginnen jeweils mit den Zeichen <code>&gt;</code> und <code>&lt;</code>. Steht am Anfang ein <code>&gt;</code> bedeutet das, dass diese Zeile exakt so an CouchDB geschickt wurde (ohne das <code>&gt;</code>). Ein <code>&lt;</code> am Anfang bedeutet, dass diese Zeile genau so von CouchDB zurück an <code>curl</code> geschickt wurde.

<pre>
&gt; PUT /albums-backup HTTP/1.1
</pre>

<p>Damit wird der HTTP Request eingeleitet. Die <em>Methode</em> ist <code>PUT</code>, die <em>URI</em> ist <code>/albums-backup</code> und die  HTTP Version ist <code>HTTP/1.1</code>. Es gibt auch ein <code>HTTP/1.0</code> welches in manchen Fällen etwas einfacher ist, doch im allgemeinen sollte man  <code>HTTP/1.1</code> verwenden.

<p>Anschließend folgen eine Menge von <em>Request Headern</em>, die zusätzliche Informationen über den Request enthalten.

<pre>
&gt; User-Agent: curl/7.16.3 (powerpc-apple-darwin9.0) libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
</pre>

<p>Der <code>User-Agent</code> Header teilt CouchDB mit, welche Software den Request gerade durchführt. Für uns ist das nichts Neues: es ist <code>curl</code>. Dieser Header wird oft in Web Anwendungen benutzt, um Fehler mit bestimmten HTTP Clients (z.B. Browsern) zu umgehen. Der Server kann dann eine auf den Client zugeschnittene Antwort schicken. Zudem kann man an dem Header erkennen, auf welcher Plattform der Benutzer ist, was für statistische Zwecke ganz hilfreich sein kann.  Für CouchDB dagegen ist der <code>User-Agent</code> Header irrelevant.

<pre>
&gt; Host: 127.0.0.1:5984
</pre>

<p>Der <code>Host</code> Header ist Pflicht in HTTP 1.1. Er sagt dem Server, welcher Hostname in der URL stand.

<pre>
&gt; Accept: */*
</pre>

<p>Der <code>Accept</code> Header sagt CouchDB, dass <code>curl</code> jeden Medientyp als Antwort akzeptiert. Wir werden gleich noch sehen, wie man das nutzen kann.

<pre>
&gt;
</pre>

<p>Eine leere Zeile zeigt das Ende der Liste der Request Header an und markiert den Beginn der Daten, die wir an den Server schicken. In dem Fall schicken wir keine Daten, insofern ist der Rest der Ausgabe die HTTP Response. 

<pre>
&lt; HTTP/1.1 201 Created
</pre>

<p>Die erste Zeile der Antwort von CouchDB enthält die HTTP Version (damit teilt uns der Server seine höchste HTTP Version mit, die er versteht), einen HTTP <em>Status Code</em> und eine Status Meldung. Unterschiedliche Requests liefern unterschiedliche Status Codes zurück. Es gibt eine ganze Menge an vordefinierten Status Codes, welche dem Client (in unserem Fall <code>curl</code>) sagen, welchen Effekt der Request auf den Server hatte. Ist jedoch ein Fehler aufgetreten, so enthält der Status Code den Typ des Fehlers. <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a> (die HTTP Spezifikation) beschreibt genau, welches Verhalten welchen Status Code auslösen sollte. CouchDB hält sich genau an den RFC.

<p>Der Status Code <em>201 Created</em> teilt dem Client mit, dass die Ressource, gegen die der Request gemacht wurde (<code>/albums-backup</code>), erfolgreich angelegt wurde. Das ist das keine große Überraschung, doch wir haben vorher bereits gesehen, das CouchDB bei dem gleichen Request auch einen Fehler melden kann, wenn die Datenbank bereits existiert. Dabei könnte auch ein anderer Status Code zurückgeliefert worden sein. Zum Beispiel sind alle Status Codes größer oder gleich 400 Fehlercodes. Eine einfache Fehlerprüfung kann sich das zunutze mache, indem man auf Status Code <code>&gt;= 400</code> prüft.

<pre>
&lt; Server: CouchDB/0.10.1 (Erlang OTP/R13B)
</pre>

<p>Der <code>Server</code> Header eignet sich gut zur Diagnose. Er enthält die CouchDB Version und die Version des zugrundeliegenden Erlang Systems. Meist kann man diesen Header ignorieren, doch es ist gut zu wissen, dass er da ist, falls man ihn braucht.

<pre>
&lt; Date: Sun, 05 Jul 2009 22:48:28 GMT
</pre>

<p>In dem <code>Date</code> Header teilt uns CouchDB die Serverzeit mit. Da Client und Server Zeit nicht notwendigerweise synchronisiert sind, hat dieser Header reinen Informationscharacter. Unter keinen Umständen sollte man sich in einer Anwendung auf diesen Header verlassen.

<pre>
&lt; Content-Type: text/plain;charset=utf-8
</pre>

<p>The <code>Content-Type</code> header tells you which MIME type the HTTP response body is and its encoding. We already know CouchDB returns JSON strings. The appropriate <code>Content-Type</code> header is <code>application/json</code>. Why do we see <code>text/plain</code>? This is where pragmatism wins over purity. Sending an <code>application/json</code> <code>Content-Type</code> header will make a browser offer you the returned JSON for download instead of just displaying it. Since it is extremely useful to be able to test CouchDB from a browser, CouchDB sends a <code>text/plain</code> content type, so all browsers will display the JSON as text.

<p>There are some browser extensions that make your browser JSON-aware, but they are not installed by default.

<p>Do you remember the <code>Accept</code> request header and how it is set to <code>\*/\* -&gt; */*</code> to express interest in any MIME type? If you send <code>Accept: application/json</code> in your request, CouchDB knows that you can deal with a pure JSON response with the proper <code>Content-Type</code> header and will use it instead of <code>text/plain</code>.

<pre>
&lt; Content-Length: 12
</pre>

<p>The <code>Content-Length</code> header simply tells us how many bytes the response body has.

<pre>
&lt; Cache-Control: must-revalidate
</pre>

<p>This <code>Cache-Control</code> header tells you, or any proxy server between CouchDB and you, not to cache this response.

<pre>
&lt;
</pre>

<p>This empty line tells us we’re done with the response headers and what follows now is the response body.

<pre>
{"ok":true}
</pre>

<p>We’ve seen this before.

<pre>
* Connection #0 to host 127.0.0.1 left intact
* Closing connection #0
</pre>

<p>The last two lines are <code>curl</code> telling us that it kept the TCP connection it opened in the beginning open for a moment, but then closed it after it received the entire response.

<p>Throughout the book, we’ll show more requests with the <code>-v</code> option, but we’ll omit some of the headers we’ve seen here and include only those that are important for the particular request.

<p>Creating databases is all fine, but how do we get rid of one? Easy—just change the HTTP method:

<pre>
&gt; curl -vX DELETE http://127.0.0.1:5984/albums-backup
</pre>

<p>This deletes a CouchDB database. The request will remove the file that the database contents are stored in. There is no “Are you sure?” safety net or any “Empty the trash” magic you’ve got to do to delete a database. Use this command with care. Your data will be deleted without a chance to bring it back easily if you don’t have a backup copy.

<p>This section went knee-deep into HTTP and set the stage for discussing the rest of the core CouchDB API. Next stop: documents.

<h3 id="documents">Documents</h3>

<p>Documents are CouchDB’s central data structure. The idea behind a document is, unsurprisingly, that of a real-world document—a sheet of paper such as an invoice, a recipe, or a business card. We already learned that CouchDB uses the JSON format to store documents. Let’s see how this storing works at the lowest level.

<p>Each document in CouchDB has an <em>ID</em>. This ID is unique per database. You are free to choose any string to be the ID, but for best results we recommend a UUID (or GUID), i.e., a Universally (or Globally) Unique IDentifier. UUIDs are random numbers that have such a low collision probability that everybody can make thousands of UUIDs a minute for millions of years without ever creating a duplicate. This is a great way to ensure two independent people cannot create two different documents with the same ID. Why should you care what somebody else is doing? For one, that somebody else could be you at a later time or on a different computer; secondly, CouchDB replication lets you share documents with others and using UUIDs ensures that it all works. But more on that later; let’s make some documents:

<pre>
curl -X PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af -d '{"title":"There is Nothing Left to Lose","artist":"Foo Fighters"}'
</pre>

<p>CouchDB replies:

<pre>
{"ok":true,"id":"6e1295ed6c29495e54cc05947f18c8af","rev":"1-2902191555"}
</pre>

<p>The <code>curl</code> command appears complex, but let’s break it down. First, <code>-X PUT</code> tells <code>curl</code> to make a PUT request. It is followed by the URL that specifies your CouchDB IP address and port. The resource part of the URL <code>/albums/6e1295ed6c29495e54cc05947f18c8af</code> specifies the location of a document inside our <code>albums</code> database. The wild collection of numbers and characters is a UUID. This UUID is your document’s ID. Finally, the <code>-d</code> flag tells <code>curl</code> to use the following string as the body for the PUT request. The string is a simple JSON structure including <code>title</code> and <code>artist</code> attributes with their respective values.

<div class="aside note">

<p>If you don’t have a UUID handy, you can ask CouchDB to give you one (in fact, that is what we did just now without showing you). Simply send a GET request to <code>/_uuids</code>:

<pre>
curl -X GET http://127.0.0.1:5984/_uuids
</pre>

<p>CouchDB replies:

<pre>
{"uuids":["6e1295ed6c29495e54cc05947f18c8af"]}
</pre>

<p>Voilá, a UUID. If you need more than one, you can pass in the <code>?count=10</code> HTTP parameter to request 10 UUIDs, or really, any number you need.

</div>

<p>To double-check that CouchDB isn’t lying about having saved your document (it usually doesn’t), try to retrieve it by sending a GET request:

<pre>
curl -X GET http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af
</pre>

<p>We hope you see a pattern here. Everything in CouchDB has an address, a URI, and you use the different HTTP methods to operate on these URIs.

<p>CouchDB replies:

<pre>
{"_id":"6e1295ed6c29495e54cc05947f18c8af","_rev":"1-2902191555","title":"There is Nothing Left to Lose","artist":"Foo Fighters"}
</pre>

<p>This looks a lot like the document you asked CouchDB to save, which is good. But you should notice that CouchDB added two fields to your JSON structure. The first is <code>_id</code>, which holds the UUID we asked CouchDB to save our document under. We always know the ID of a document if it is included, which is very convenient.

<p>The second field is <code>_rev</code>. It stands for <em>revision</em>.

<h4 id="revisions">Revisions</h4>

<p>If you want to change a document in CouchDB, you don’t tell it to go and find a field in a specific document and insert a new value. Instead, you load the full document out of CouchDB, make your changes in the JSON structure (or object, when you are doing actual programming), and save the entire new revision (or version) of that document back into CouchDB. Each revision is identified by a new <code>_rev</code> value.

<p>If you want to update or delete a document, CouchDB expects you to include the <code>_rev</code> field of the revision you wish to change. When CouchDB accepts the change, it will generate a new revision number. This mechanism ensures that, in case somebody else made a change unbeknownst to you before you got to request the document update, CouchDB will not accept your update because you are likely to overwrite data you didn’t know existed. Or simplified: whoever saves a change to a document first, wins. Let’s see what happens if we don’t provide a <code>_rev</code> field (which is equivalent to providing a outdated value):

<pre>
curl -X PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af -d '{"title":"There is Nothing Left to Lose","artist":"Foo Fighters","year":"1997"}'
</pre>

<p>CouchDB replies:

<pre>
{"error":"conflict","reason":"Document update conflict."}
</pre>

<p>If you see this, add the latest revision number of your document to the JSON structure:

<pre>
curl -X PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af -d '{"_rev":"1-2902191555","title":"There is Nothing Left to Lose", "artist":"Foo Fighters","year":"1997"}'
</pre>

<p>Now you see why it was handy that CouchDB returned that <code>_rev</code> when we made the initial request. CouchDB replies:

<pre>
{"ok":true,"id":"6e1295ed6c29495e54cc05947f18c8af","rev":"2-2739352689"}
</pre>

<p>CouchDB accepted your write and also generated a new revision number. The revision number is the md5 hash of the transport representation of a document with an <code>N-</code> prefix denoting the number of times a document got updated. This is useful for replication. See <a href="conflicts.html">Chapter 17, Conflict Management</a> for more information.

<p>There are multiple reasons why CouchDB uses this revision system, which is also called Multi-Version Concurrency Control (MVCC). They all work hand-in-hand, and this is a good opportunity to explain some of them.

<p>One of the aspects of the HTTP protocol that CouchDB uses is that it is <em>stateless</em>. What does that mean? When talking to CouchDB you need to <em>make requests</em>. Making a request includes opening a network connection to CouchDB, exchanging bytes, and closing the connection. This is done every time you make a request. Other protocols allow you to open a connection, exchange bytes, keep the connection open, exchange more bytes later—maybe depending on the bytes you exchanged at the beginning—and eventually close the connection. Holding a connection open for later use requires the server to do extra work. One common pattern is that for the lifetime of a connection, the client has a consistent and static view of the data on the server. Managing huge amounts of parallel connections is a significant amount of work. HTTP connections are usually short-lived, and making the same guarantees is a lot easier. As a result, CouchDB can handle many more concurrent connections.

<p>Another reason CouchDB uses MVCC is that this model is simpler conceptually and, as a consequence, easier to program. CouchDB uses less code to make this work, and less code is always good because the ratio of defects per lines of code is static.

<p>The revision system also has positive effects on replication and storage mechanisms, but we’ll explore these later in the book.

<div class="aside warning">

<p>The terms <em>version</em> and <em>revision</em> might sound familiar (if you are programming without version control, drop this book right now and start learning one of the popular systems). Using new versions for document changes works a lot like version control, but there’s an important difference: CouchDB does <em>not</em> guarantee that older versions are kept around.

</div>

<h4 id="detail">Documents in Detail</h4>

<p>Now let’s have a closer look at our document creation requests with the <code>curl</code> <code>-v</code> flag that was helpful when we explored the database API earlier. This is also a good opportunity to create more documents that we can use in later examples.

<p>We’ll add some more of our favorite music albums. Get a fresh UUID from the <code>/_uuids</code> resource. If you don’t remember how that works, you can look it up a few pages back.

<pre>
curl -vX PUT http://127.0.0.1:5984/albums/70b50bfa0a4b3aed1f8aff9e92dc16a0 -d '{"title":"Blackened Sky","artist":"Biffy Clyro","year":2002}'
</pre>

<div class="aside note">

<p>By the way, if you happen to know more information about your favorite albums, don’t hesitate to add more properties. And don’t worry about not knowing all the information for all the albums. CouchDB’s schema-less documents can contain whatever you know. After all, you should relax and not worry about data.

</div>

<p>Now with the <code>-v</code> option, CouchDB’s reply (with only the important bits shown) looks like this:

<pre>
&gt; PUT /albums/70b50bfa0a4b3aed1f8aff9e92dc16a0 HTTP/1.1
&gt;
&lt; HTTP/1.1 201 Created
&lt; Location: http://127.0.0.1:5984/albums/70b50bfa0a4b3aed1f8aff9e92dc16a0
&lt; Etag: "1-2248288203"
&lt;
{"ok":true,"id":"70b50bfa0a4b3aed1f8aff9e92dc16a0","rev":"1-2248288203"}
</pre>

<p>We’re getting back the <code>201 Created</code> HTTP status code in the response headers, as we saw earlier when we created a database. The <code>Location</code> header gives us a full URL to our newly created document. And there’s a new header. An Etag in HTTP-speak identifies a specific version of a resource. In this case, it identifies a specific version (the first one) of our new document. Sound familiar? Yes, conceptually, an Etag is the same as a CouchDB document revision number, and it shouldn’t come as a surprise that CouchDB uses revision numbers for Etags. Etags are useful for caching infrastructures. We’ll learn how to use them in <a href="show.html">Chapter 8, Show Functions</a>.

<h5 id="attachments">Attachments</h5>

<p>CouchDB documents can have attachments just like an email message can have attachments. An attachment is identified by a name and includes its MIME type (or Content-Type) and the number of bytes the attachment contains. Attachments can be any data. It is easiest to think about attachments as files attached to a document. These files can be text, images, Word documents, music, or movie files. Let’s make one.

<p>Attachments get their own URL where you can upload data. Say we want to add the album artwork to the <code>6e1295ed6c29495e54cc05947f18c8af</code> document (“There is Nothing Left to Lose”), and let’s also say the artwork is in a file <code>artwork.jpg</code> in the current directory:

<pre>
&gt; curl -vX PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af/ artwork.jpg?rev=2-2739352689 --data-binary @artwork.jpg -H "Content-Type: image/jpg"
</pre>

<p>The <code>-d@</code> option tells <code>curl</code> to read a file’s contents into the HTTP request body. We’re using the <code>-H</code> option to tell CouchDB that we’re uploading a JPEG file. CouchDB will keep this information around and will send the appropriate header when requesting this attachment; in case of an image like this, a browser will render the image instead of offering you the data for download. This will come in handy later. Note that you need to provide the current revision number of the document you’re attaching the artwork to, just as if you would update the document. Because, after all, attaching some data is changing the document.

<p>You should now see your artwork image if you point your browser to <code>http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af/artwork.jpg</code>.

<p>If you request the document again, you’ll see a new member:

<pre>
curl http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af
</pre>

<p>CouchDB replies:

<pre>
{"_id":"6e1295ed6c29495e54cc05947f18c8af","_rev":"3-131533518","title": "There is Nothing Left to Lose","artist":"Foo Fighters","year":"1997","_attachments":{"artwork.jpg":{"stub":true,"content_type":"image/jpg","length":52450}}}
</pre>

<p><code>_attachments</code> is a list of keys and values where the values are JSON objects containing the attachment metadata. <code>stub=true</code> tells us that this entry is just the metadata. If we use the <code>?attachments=true</code> HTTP option when requesting this document, we’d get a Base64-encoded string containing the attachment data.

<p>We’ll have a look at more document request options later as we explore more features of CouchDB, such as replication, which is the next topic.

<h3 id="replication">Replication</h3>

<p>CouchDB replication is a mechanism to synchronize databases. Much like <code>rsync</code> synchronizes two directories locally or over a network, replication synchronizes two databases locally or remotely.

<p>In a simple POST request, you tell CouchDB the <em>source</em> and the <em>target</em> of a replication and CouchDB will figure out which documents and new document revisions are on <em>source</em> that are not yet on <em>target</em>, and will proceed to move the missing documents and revisions over.

<p>We’ll take an in-depth look at replication later in the book; in this chapter, we’ll just show you how to use it.

<p>First, we’ll create a target database. Note that CouchDB won’t automatically create a target database for you, and will return a replication failure if the target doesn’t exist (likewise for the source, but that mistake isn’t as easy to make):

<pre>
curl -X PUT http://127.0.0.1:5984/albums-replica
</pre>

<p>Now we can use the database <code>albums-replica</code> as a replication target:

<pre>
curl -vX POST http://127.0.0.1:5984/_replicate -d '{"source":"albums","target":"albums-replica"}'
</pre>

<div class="aside note">

<p>As of version 0.11, CouchDB supports the option <code>"create_target":true</code> placed in the JSON POSTed to the <code>_replicate</code> URL. It implicitly creates the target database if it doesn’t exist.

</div>

<p>CouchDB replies (this time we formatted the output so you can read it more easily):

<pre>
{
  "history": [
    {
      "start_last_seq": 0,
      "missing_found": 2,
      "docs_read": 2,
      "end_last_seq": 5,
      "missing_checked": 2,
      "docs_written": 2,
      "doc_write_failures": 0,
      "end_time": "Sat, 11 Jul 2009 17:36:21 GMT",
      "start_time": "Sat, 11 Jul 2009 17:36:20 GMT"
    }
  ],
  "source_last_seq": 5,
  "session_id": "924e75e914392343de89c99d29d06671",
  "ok": true
}
</pre>

<p>CouchDB maintains a <em>session history</em> of replications. The response for a replication request contains the history entry for this <em>replication session</em>. It is also worth noting that the request for replication will stay <em>open</em> until replication closes. If you have a lot of documents, it’ll take a while until they are all replicated and you won’t get back the replication response until all documents are replicated. It is important to note that replication replicates the database only as it was at the point in time when replication was started. So, any additions, modifications, or deletions subsequent to the start of replication will not be replicated.

<p>We’ll punt on the details again—the <code>"ok": true</code> at the end tells us all went well. If you now have a look at the <code>albums-replica</code> database, you should see all the documents that you created in the <code>albums</code> database. Neat, eh?

<p>What you just did is called <em>local replication</em> in CouchDB terms. You created a local copy of a database. This is useful for backups or to keep snapshots of a specific state of your data around for later. You might want to do this if you are developing your applications but want to be able to roll back to a stable version of your code and data.

<p>There are more types of replication useful in other situations. The <code>source</code> and <code>target</code> members of our replication request are actually links (like in HTML) and so far we’ve seen links relative to the server we’re working on (hence <em>local</em>). You can also specify a remote database as the target:

<pre>
curl -vX POST http://127.0.0.1:5984/_replicate -d '{"source":"albums","target":"http://127.0.0.1:5984/albums-replica"}'
</pre>

<p>Using a local <code>source</code> and a remote <code>target</code> database is called <em>push replication</em>. We’re pushing changes to a remote server.

<div class="aside note">

<p>Since we don’t have a second CouchDB server around just yet, we’ll just use the absolute address of our single server, but you should be able to infer from this that you can put any remote server in there.

</div>

<p>This is great for sharing local changes with remote servers or buddies next door.

<p>You can also use a remote <code>source</code> and a local <code>target</code> to do a <em>pull replication</em>. This is great for getting the latest changes from a server that is used by others:

<pre>
curl -vX POST http://127.0.0.1:5984/_replicate -d '{"source":"http://127.0.0.1:5984/albums-replica","target":"albums"}'
</pre>

<p>Finally, you can run <em>remote replication</em>, which is mostly useful for management operations:

<pre>
curl -vX POST http://127.0.0.1:5984/_replicate -d '{"source":"http://127.0.0.1:5984/albums","target":"http://127.0.0.1:5984/albums-replica"}'
</pre>

<div class="aside note">

<p><strong>CouchDB and REST</strong>

<p>CouchDB prides itself on having a <em>RESTful API</em>, but these replication requests don’t look very RESTy to the trained eye. What’s up with that? While CouchDB’s core database, document, and attachment API are RESTful, not all of CouchDB’s API is. The replication API is one example. There are more, as we’ll see later in the book.

<p>Why are there RESTful and non-RESTful APIs mixed up here? Have the developers been too lazy to go REST all the way? Remember, REST is an architectural style that lends itself to certain architectures (such as the CouchDB document API). But it is not a one-size-fits-all. Triggering an event like replication does not make a whole lot of sense in the REST world. It is more like a traditional remote procedure call. And there is nothing wrong with this.

<p>We very much believe in the “use the right tool for the job” philosophy, and REST does not fit every job. For support, we refer to Leonard Richardson and Sam Ruby who wrote <a href="http://oreilly.com/catalog/9780596529260">RESTful Web Services</a> (O’Reilly), as they share our view.

</div>

<h3 id="wrap">Wrapping Up</h3>

<p>This is still not the full CouchDB API, but we discussed the essentials in great detail. We’re going to fill in the blanks as we go. For now, we believe you’re ready to start building CouchDB applications.
